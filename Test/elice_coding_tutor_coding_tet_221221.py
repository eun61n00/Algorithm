# 1
"""
콜라츠 추측

콜라츠 추측이란 2 이상의 정수에 대해 다음과 같은 작업을 반복하면 언젠가는 1이 될거라는 추측이에요.

짝수면 2로 나눈다.
홀수면 3을 곱하고 1을 더한다.

이렇게 해봅시다!

입력받은 수가 짝수라면 2로 나누고 정수의 형태로 출력해 보세요.
입력받은 수가 홀수라면 3을 곱하고 1을 더해서 출력해 보세요.
1~2번을 수가 1이 될때까지 반복해 보세요.
"""
# 숫자를 입력받고 콜라츠 추측 과정을 출력해 주세요.
input_num = int(input())

while input_num != 1:
    if input_num % 2 == 0:
        input_num /= 2
        print(int(input_num))
    else:
        input_num = input_num * 3 + 1
        print(int(input_num))


# 2
"""
수 뒤집기

어떤 수가 입력되면, 그 수와 그 수를 뒤집은 수 중에서 더 큰 것을 출력해 보세요.
이렇게 해봅시다!

입력된 수와 뒤집은 수를 비교해서 더 큰 값을 출력하는 코드를 완성해 보세요.
"""
# 입력받은 수를 뒤집고 원래 수와 비교한 뒤 더 큰 수를 출력해 주세요.
input_num = input()
reverse_num = int(input_num[::-1])
input_num = int(input_num)

print(input_num if input_num > reverse_num else reverse_num)


# 3
"""
에니그마 해독기 만들기

2차 세계대전은 가장 많은 사람의 희생된 20세기 최고의 비극이었어요. 전 세계의 많은 젊은이와 무고한 사람들이 전쟁으로 희생되었죠.

치열한 전투로 수많은 사람이 사망했지만, 2차 세계대전 시기는 전쟁에서 이기기 위해 많은 나라가 그 어떤 시기보다도 과학기술에 많은 투자를 했어요. 덕분에 과학과 기술 분야의 많은 발명과 발전이 있었던 시기이기도 해요.


(사진: 독일 에니그마 머신, 위키피디아)

에니그마(Enigma, 수수께끼)는 독일군이 전장에서 사용했던 암호 생성 장치예요.

독일어 알파벳 각각에 대하여 다른 알파벳에 임의로 대응시킨 다음, 이렇게 대응된 알파벳으로 전신 부호를 발송했어요.

예를 들어 a는 p, b는 q, c는 r에 대응시켜 암호화한 전신을 보낼 때 ‘abc’는 ‘pqr’로 전달됩니다. 해독 코드가 담긴 문서는 사람을 써서 반대편에 미리 전달해두고, 이것을 참고해서 전신을 해독했어요.

파이썬으로 이 에니그마 코드를 해독할 수 있는 프로그램을 작성해 보세요.

이렇게 해봅시다!

연합군이 독일군의 통신 내용을 알 수 없도록 암호의 알파벳을 키로, 대응하는 알파벳을 값으로 저장한 딕셔너리 signal이 있어요. 함수 code에 암호가 입력되면, 그 암호를 signal 딕셔너리의 키에 대입해 키의 값들을 반환하는 함수를 완성해 보세요.
signal에 존재하지 않는 암호(예: 띄어쓰기)는 해독을 거치지 않고 그대로 반환해 보세요.
"""
signal = {'a': 'n', 'b': 'd', 'c': 'a', 'd': 'b', 'e': 'e', 'f': 'l', 'g': 'j', 'h': 'o', 'i': 'z', 'j': 'u', 'k': 'y', 'l': 'v', 'm': 'w', 'n': 'q', 'o': 'x', 'p': 'r', 'q': 'p', 'r': 'f', 's': 'g', 't': 't', 'u': 'm', 'v': 'h', 'w': 'i', 'x': 'c', 'y': 'k', 'z': 's'}

# signal을 해독해서 반환하는 함수를 작성해 주세요.
def code(code):
    result = ''
    for c in code:
        if c not in signal.keys(): 
            result += c
            continue
        result += signal[c]
    return result
 
# 어떤 값이 출력될까요? 해독이 되는지 확인해 보세요.
print(code('w fhle khj'))


# 4
"""
토끼와 거북이의 달리기 경주

토끼와 거북이가 달리기 경주를 시작했어요.

토끼는 N분에 한번 휴식을 하고 거북이는 M분에 한번 휴식을 한다고 해요.

토끼와 거북이가 처음으로 같은 타이밍에 쉬는 시간은 언제일까요?
[시간제한]

각 실행 케이스마다 1.5초의 시간이 주어져요.
이렇게 해봅시다!

토끼의 휴식 시간 N과 거북이의 휴식 시간 M이 인자로 주어졌을 때, 토끼와 거북이가 동시에 휴식하는 최초의 시간을 출력하는 코드를 작성해 보세요.
"""
# 토끼와 거북이가 처음으로 동시에 쉬는 시간을 구해서 출력해 주세요.
a, b = map(int, input().split())
for i in range(max(a, b), (a*b)+1):
    if (i % a == 0) and (i % b == 0):
        print(i)


# 5
"""
골드바흐의 추측

골드바흐의 추측이란 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다는 추측이에요.

예를 들어 4, 6, 8은 다음과 같이 나타낼 수 있어요.

4 = 2 + 2
6 = 3 + 3
8 = 3 + 5

현재 이 추측은 참인지 거짓인지 아직 증명되지 않았으나 충분히 크지 않은 수에 대해서는 컴퓨터를 통해 참으로 결론을 내린 상태예요.

여러분도 한번 짝수를 두 소수의 합으로 나타내어 보세요.

[입력]

N
N개의 짝수가 공백으로 구분되어 입력돼요.
각 짝수는 모두 최대 10,000을 넘지 않아요.

[출력]

줄마다 합계가 짝수가 되는 두 소수를 작은 소수부터 차례대로 출력해요.

만약 해당 짝수를 만드는 소수의 쌍이 여러 개라면 가장 두 소수의 차이가 적은 것을 출력해요.

[시간제한]

각 실행 케이스마다 1.5초의 시간이 주어져요.
이렇게 해봅시다!

prime.py를 확인해 보세요. prime_list안에는 1~10,000 숫자 사이에 존재하는 모든 소수가 오름차순으로 저장되어 있어요.
두 소수를 합해서 입력받은 짝수를 만들 수 있는 소수의 리스트를 반환하는 goldbach() 함수를 완성해 보세요.
매개변수로 짝수 리스트를 받아요.
짝수를 만드는 소수쌍의 리스트를 반환해요.
만약 해당 짝수를 만드는 소수의 쌍이 여러 개라면 가장 두 소수의 차이가 적은 것을 선택해요.
"""
# prime_list는 1부터 10000사이의 소수가 오름차순으로 저장된 리스트예요.
from prime import prime_list

# 합계가 짝수가 되는 두 소수를 찾는 함수예요.
def goldbach(arr):
    # 합계가 짝수가 되는 두 소수를 작은 수부터 차례로 리스트에 저장해 주세요.
    result = []
    
    for num in arr:
        a, b = num // 2, num // 2
        while a > 0:
            if a in prime_list and b in prime_list:
                result.append([a, b])
                break
            else:
                a -= 1
                b += 1

    return result

arr = [int(x) for x in input().split()]

for i in goldbach(arr):
    print(i[0], i[1])
